# 故障排除指南

<cite>
**本文档引用的文件**
- [README.md](file://README.md)
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py)
- [Recover/recover_system.py](file://Recover/recover_system.py)
- [start_dynamic_redundancy.sh](file://start_dynamic_redundancy.sh)
- [requirements.txt](file://requirements.txt)
</cite>

## 目录
1. [简介](#简介)
2. [问题分类索引](#问题分类索引)
3. [常见问题排查](#常见问题排查)
4. [高级故障诊断](#高级故障诊断)
5. [系统恢复指南](#系统恢复指南)
6. [调试技巧](#调试技巧)
7. [预防措施](#预防措施)

## 简介

本故障排除指南旨在帮助用户快速识别和解决CloudResourceOptimizer项目在部署和运行过程中可能遇到的各种问题。该指南涵盖了从基础的环境配置到复杂的系统级问题的所有常见场景，并提供了详细的解决方案和预防措施。

## 问题分类索引

### 按严重程度分类

**高危问题（需要立即处理）**
- 权限错误导致的系统崩溃
- 内存调整失败引发的系统不稳定
- 磁盘空间不足导致的功能异常

**中危问题（影响功能但不致命）**
- Glances监控启动失败
- 配置文件读取错误
- 平台检测失败

**低危问题（轻微影响）**
- 日志文件过多
- 性能监控延迟
- 临时文件清理失败

### 按发生频率分类

**高频问题**
- 权限错误
- 依赖包缺失
- 配置文件格式错误

**中频问题**
- 磁盘空间不足
- 内存不足
- 平台兼容性问题

**低频问题**
- 网络连接问题
- 时间同步问题
- 文件编码问题

## 常见问题排查

### 1. 无法启动Glances监控

**症状描述**
- 启动脚本显示"未安装glances，无法启动监控服务"
- Web界面无法访问（端口61208）
- 日志中出现glances相关错误

**根本原因分析**
1. 系统未安装glances包
2. pip安装失败或版本不兼容
3. 系统防火墙阻止端口61208
4. 其他进程占用了61208端口

**解决步骤**

#### 方案一：手动安装glances
```bash
# 方法1：使用pip安装
pip install glances>=3.2.7

# 方法2：使用系统包管理器安装
# CentOS/RHEL
sudo yum install glances -y

# Ubuntu/Debian
sudo apt-get install glances -y

# 方法3：针对特定平台
# 麒麟系统
sudo apt-get install glances -y

# OpenEuler系统
sudo dnf install glances -y
```

#### 方案二：禁用Glances监控
编辑`.env`配置文件，将以下参数设置为false：
```
GLANCES_ENABLED=false
```

#### 方案三：检查端口占用
```bash
# 检查61208端口是否被占用
netstat -tlnp | grep 61208

# 如果被占用，可以更换端口
# 修改dynamic_redundancy.py中的glances启动参数
```

**节来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L490-L556)

### 2. 权限错误

**症状描述**
- "Permission denied"错误
- 无法创建临时文件
- 无法访问系统资源
- 进程被拒绝访问

**根本原因分析**
1. 脚本未以管理员/root权限运行
2. 文件系统权限设置不当
3. SELinux/AppArmor限制
4. 用户组权限不足

**解决步骤**

#### Windows系统
```cmd
# 以管理员身份运行命令提示符
右键点击"命令提示符" -> "以管理员身份运行"

# 或者使用PowerShell
右键点击"Windows PowerShell" -> "以管理员身份运行"
```

#### Linux系统
```bash
# 切换到root用户
sudo su -

# 或者使用sudo运行脚本
sudo python scripts/dynamic_reduundancy.py

# 检查文件权限
chmod +x scripts/dynamic_redundancy.py
chmod +x start_dynamic_redundancy.sh
```

#### 权限检查清单
1. 确认脚本文件具有可执行权限
2. 检查logs目录写入权限
3. 验证config目录读取权限
4. 确保临时文件目录有足够的空间

**节来源**
- [start_dynamic_redundancy.sh](file://start_dynamic_redundancy.sh#L10-L15)

### 3. 内存调整失败

**症状描述**
- 内存使用率始终低于目标值
- 内存占用脚本启动失败
- 系统报告内存不足
- 进程创建失败

**根本原因分析**
1. 可用内存总量不足
2. 系统内存限制（ulimit）
3. 内存碎片化严重
4. 其他进程占用大量内存

**解决步骤**

#### 步骤1：检查系统内存状态
```bash
# 查看系统内存使用情况
free -h

# 查看内存限制
ulimit -a | grep memory

# 查看内存统计信息
cat /proc/meminfo
```

#### 步骤2：调整内存配置
编辑`.env`文件，适当降低内存目标利用率：
```
# 对于内存较小的系统
TARGET_UTILIZATION_SMALL=20
TARGET_UTILIZATION_LARGE=35
```

#### 步骤3：清理内存
```bash
# Linux系统清理页面缓存
echo 3 | sudo tee /proc/sys/vm/drop_caches

# Windows系统重启或清理内存
# 使用任务管理器结束不必要的进程
```

#### 步骤4：监控内存使用
```python
# 使用psutil手动监控内存
import psutil
memory = psutil.virtual_memory()
print(f"可用内存: {memory.available / (1024*1024*1024):.2f} GB")
```

### 4. 磁盘空间不足

**症状描述**
- 磁盘占用脚本跳过执行
- 临时文件创建失败
- 系统报告磁盘空间不足
- 日志文件过多

**根本原因分析**
1. 数据盘空间不足（<1GB）
2. 临时文件未及时清理
3. 日志文件积累过多
4. 系统分区空间不足

**解决步骤**

#### 步骤1：检查磁盘空间
```bash
# 查看所有磁盘空间使用情况
df -h

# 查看特定目录的大小
du -sh /path/to/directory/*

# 查看最大可用空间的目录
df -h | sort -k4 -h | tail -n 1
```

#### 步骤2：清理磁盘空间
```bash
# 清理临时文件
find /tmp -type f -atime +7 -delete
find /var/tmp -type f -atime +7 -delete

# 清理日志文件
find ./logs -name "*.log" -mtime +30 -delete

# 清理旧的备份文件
find ./backups -name "*.bak" -mtime +30 -delete
```

#### 步骤3：调整磁盘配置
编辑`.env`文件，设置合适的磁盘路径：
```
# 设置磁盘占用路径
DISK_STRESS_PATH=/data/disk_stress

# 调整磁盘占用大小
LOW_UTIL_DISK_SIZE=100MB
MED_UTIL_DISK_SIZE=50MB
HIGH_UTIL_DISK_SIZE=25MB
```

#### 步骤4：启用磁盘监控
```bash
# 检查磁盘监控配置
grep DATA_DISK_ONLY .env

# 确保设置为true
DATA_DISK_ONLY=true
```

**节来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L380-L420)

### 5. 配置文件编码错误

**症状描述**
- "UnicodeDecodeError"错误
- 配置文件读取失败
- 特殊字符显示异常
- 参数解析错误

**根本原因分析**
1. 配置文件使用非UTF-8编码
2. 文件包含BOM标记
3. 特殊字符未正确转义
4. 文件格式不正确

**解决步骤**

#### 步骤1：检查文件编码
```bash
# 检查文件编码
file -bi config/.env

# 使用iconv转换编码
iconv -f GBK -t UTF-8 config/.env -o config/.env.utf8
mv config/.env.utf8 config/.env
```

#### 步骤2：验证配置文件格式
```bash
# 检查配置文件语法
python -c "
try:
    from dotenv import load_dotenv
    load_dotenv('config/.env')
    print('配置文件格式正确')
except Exception as e:
    print(f'配置文件错误: {e}')
"
```

#### 步骤3：修复特殊字符
```bash
# 替换特殊字符
sed -i 's/\r$//' config/.env
sed -i 's/[[:space:]]*$//' config/.env
```

### 6. 定时任务冲突

**症状描述**
- 脚本启动失败
- 进程重复启动
- 资源竞争
- 端口冲突

**根本原因分析**
1. 多个实例同时运行
2. 定时任务重复执行
3. 端口被其他进程占用
4. 文件锁冲突

**解决步骤**

#### 步骤1：检查进程状态
```bash
# 查找相关进程
ps aux | grep dynamic_redundancy

# 杀死重复进程
pkill -f dynamic_redundancy
```

#### 步骤2：检查端口占用
```bash
# 检查61208端口
netstat -tlnp | grep 61208

# 检查Python进程
lsof -i :61208
```

#### 步骤3：设置进程锁
```python
# 在脚本开头添加进程锁
import fcntl
import sys

lock_file = open('/tmp/cloud_resource_optimizer.lock', 'w')
try:
    fcntl.lockf(lock_file, fcntl.LOCK_EX | fcntl.LOCK_NB)
except IOError:
    print("另一个实例已经在运行")
    sys.exit(1)
```

## 高级故障诊断

### 1. 内存泄漏检测

**症状描述**
- 系统内存持续增长
- 进程占用内存不断增加
- 系统响应变慢
- 最终导致OOM错误

**诊断步骤**

#### 步骤1：监控内存使用
```bash
# 实时监控内存使用
watch -n 1 'ps aux | grep -E "(python|memory_stresser)"'

# 使用top查看内存消耗
top -p $(pgrep -f memory_stresser)
```

#### 步骤2：分析内存快照
```python
# 创建内存分析脚本
import psutil
import gc

def analyze_memory():
    process = psutil.Process()
    print(f"进程内存使用: {process.memory_info().rss / 1024 / 1024:.2f} MB")
    
    # 强制垃圾回收
    gc.collect()
    
    # 再次检查内存
    print(f"回收后内存使用: {process.memory_info().rss / 1024 / 1024:.2f} MB")
```

#### 步骤3：设置内存限制
```bash
# 设置进程内存限制
ulimit -v 2097152  # 限制为2GB虚拟内存

# 使用cgroups限制内存
cgcreate -g memory:cloud_resource
echo 1G > /sys/fs/cgroup/memory/cloud_resource/memory.limit_in_bytes
```

### 2. 网络连接问题

**症状描述**
- Glances Web界面无法访问
- 网络监控功能失效
- 远程访问被拒绝
- 端口绑定失败

**诊断步骤**

#### 步骤1：检查网络配置
```bash
# 查看网络接口
ip addr show

# 检查防火墙规则
iptables -L
ufw status

# 检查SELinux状态
getenforce
```

#### 步骤2：测试网络连通性
```bash
# 测试本地连接
curl http://localhost:61208

# 测试远程连接
telnet server_ip 61208

# 检查端口监听状态
ss -tlnp | grep 61208
```

#### 步骤3：配置防火墙
```bash
# 开放61208端口
# CentOS/RHEL
firewall-cmd --add-port=61208/tcp --permanent
firewall-cmd --reload

# Ubuntu/Debian
ufw allow 61208/tcp
```

### 3. 平台兼容性问题

**症状描述**
- 平台检测失败
- 特定功能不可用
- 命令执行失败
- 路径解析错误

**诊断步骤**

#### 步骤1：检测平台类型
```python
import platform

def detect_platform():
    system = platform.system().lower()
    if system == 'windows':
        return 'windows'
    elif system == 'linux':
        # 尝试检测Linux发行版
        try:
            with open('/etc/os-release', 'r') as f:
                content = f.read().lower()
                if 'centos' in content:
                    return 'centos'
                elif 'ubuntu' in content:
                    return 'ubuntu'
                elif 'kylin' in content:
                    return 'kylin'
                elif 'openeuler' in content:
                    return 'openEuler'
        except:
            return 'linux_generic'
    else:
        return 'unknown'
```

#### 步骤2：设置平台配置
编辑`.env`文件：
```
# 手动设置平台类型
PLATFORM=centos  # 或 ubuntu, kylin, openEuler, linux_generic
```

#### 步骤3：测试平台功能
```bash
# 测试平台特定命令
# CentOS/RHEL
which yum
yum --version

# Ubuntu/Debian  
which apt-get
apt-get --version

# 麒麟系统
which kylin
kylin --version

# OpenEuler系统
which dnf
dnf --version
```

## 系统恢复指南

### 1. 完整系统恢复

**适用场景**
- 系统资源占用过高
- 脚本运行异常
- 需要紧急恢复系统
- 配置损坏

**恢复步骤**

#### 步骤1：停止所有资源占用进程
```bash
# Windows系统
.\Recover\recover_system.bat

# Linux系统
cd Recover
./recover_system.sh
```

#### 步骤2：清理临时文件
```bash
# 清理磁盘临时文件
find /data -name "temp_*.dat" -delete
find /tmp -name "*stress*" -delete

# 清理日志文件
find ./logs -name "*.log" -mtime +7 -delete
```

#### 步骤3：重置系统配置
```bash
# 备份当前配置
cp config/.env config/.env.backup

# 重置为默认配置
cat > config/.env << EOF
SMALL_MEMORY_MAX=8
LARGE_MEMORY_MIN=16
TARGET_UTILIZATION_SMALL=25
TARGET_UTILIZATION_LARGE=40
MONITOR_PERIOD_DAYS=30
CHECK_INTERVAL_SECONDS=60
EOF
```

#### 步骤4：重启系统
```bash
# Linux系统重启
sudo reboot

# Windows系统重启
shutdown /r /t 0
```

**节来源**
- [Recover/recover_system.py](file://Recover/recover_system.py#L1-L229)

### 2. 部分功能恢复

**适用场景**
- 只需恢复特定功能
- 需要最小化停机时间
- 配置文件损坏但不影响其他功能

**恢复步骤**

#### 步骤1：停止特定进程
```bash
# 停止CPU占用进程
pkill -f cpu_stresser.py

# 停止内存占用进程
pkill -f memory_stresser.py

# 停止磁盘占用进程
pkill -f disk_stresser.py
```

#### 步骤2：重置特定配置
```bash
# 重置CPU利用率目标
sed -i 's/TARGET_UTILIZATION_SMALL=.*/TARGET_UTILIZATION_SMALL=25/' config/.env
sed -i 's/TARGET_UTILIZATION_LARGE=.*/TARGET_UTILIZATION_LARGE=40/' config/.env

# 重置监控周期
sed -i 's/MONITOR_PERIOD_DAYS=.*/MONITOR_PERIOD_DAYS=30/' config/.env
```

#### 步骤3：重启相关服务
```bash
# 重启主脚本
python scripts/dynamic_redundancy.py

# 重启Glances监控
pkill -f glances
python scripts/dynamic_redundancy.py
```

### 3. 数据恢复

**适用场景**
- 配置数据丢失
- 日志文件损坏
- 历史数据需要恢复

**恢复步骤**

#### 步骤1：备份现有数据
```bash
# 备份配置文件
cp -r config config_backup_$(date +%Y%m%d_%H%M%S)

# 备份日志文件
cp -r logs logs_backup_$(date +%Y%m%d_%H%M%S)
```

#### 步骤2：恢复配置数据
```bash
# 从备份恢复配置
cp config_backup_YYYYMMDD_HHMMSS/.env config/

# 恢复特定配置项
grep -E "(SMALL_MEMORY_MAX|LARGE_MEMORY_MIN)" config_backup_YYYYMMDD_HHMMSS/.env > config/.env
```

#### 步骤3：重建历史数据
```python
# 重建资源使用历史
import json
from datetime import datetime, timedelta

# 创建历史数据文件
history_data = {
    'cpu': [],
    'memory': [],
    'disk': []
}

# 生成模拟历史数据
start_date = datetime.now() - timedelta(days=30)
current_date = start_date

while current_date < datetime.now():
    history_data['cpu'].append({
        'timestamp': current_date.isoformat(),
        'value': 25 + (current_date.day % 15)  # 模拟波动
    })
    current_date += timedelta(hours=1)

# 保存历史数据
with open('resource_history.json', 'w') as f:
    json.dump(history_data, f)
```

## 调试技巧

### 1. 启用详细日志模式

**步骤1：修改日志级别**
```python
# 在Logger类中添加调试级别
logging.basicConfig(
    level=logging.DEBUG,  # 设置为DEBUG级别
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
```

**步骤2：添加调试信息**
```python
# 在关键位置添加调试信息
logger.debug(f"当前内存使用: {memory.percent}%")
logger.debug(f"目标利用率: {target_utilization}%")
logger.debug(f"需要增加的内存: {memory_to_use:.2f} bytes")
```

**步骤3：监控系统调用**
```bash
# 使用strace跟踪系统调用
strace -o debug.log -f python scripts/dynamic_redundancy.py

# 使用dtrace（Linux）
dtrace -n 'syscall:::entry { printf("%s %s\n", probefunc, execname); }' > syscall.log
```

### 2. 使用psutil手动验证系统状态

**系统资源监控**
```python
import psutil
from datetime import datetime

def monitor_system_resources():
    """监控系统资源状态"""
    now = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    # CPU信息
    cpu_percent = psutil.cpu_percent(interval=1)
    cpu_count = psutil.cpu_count(logical=True)
    
    # 内存信息
    memory = psutil.virtual_memory()
    memory_percent = memory.percent
    memory_available = memory.available / (1024 * 1024 * 1024)  # GB
    
    # 磁盘信息
    disk_usage = {}
    for partition in psutil.disk_partitions():
        try:
            usage = psutil.disk_usage(partition.mountpoint)
            disk_usage[partition.mountpoint] = {
                'percent': usage.percent,
                'total': usage.total / (1024 * 1024 * 1024),  # GB
                'used': usage.used / (1024 * 1024 * 1024)      # GB
            }
        except (PermissionError, OSError):
            continue
    
    # 输出系统状态
    print(f"\n=== 系统状态 ({now}) ===")
    print(f"CPU使用率: {cpu_percent}% (逻辑核心: {cpu_count})")
    print(f"内存使用: {memory_percent}% ({memory_available:.2f}GB可用)")
    print("磁盘使用情况:")
    for mount, usage in disk_usage.items():
        print(f"  {mount}: {usage['percent']}% ({usage['used']:.2f}GB/{usage['total']:.2f}GB)")
    print("========================\n")
    
    return {
        'timestamp': now,
        'cpu': cpu_percent,
        'memory': memory_percent,
        'disk': disk_usage
    }
```

**进程监控**
```python
def monitor_processes():
    """监控系统进程"""
    print("\n=== 进程监控 ===")
    
    # 查找资源占用进程
    stresser_procs = []
    for proc in psutil.process_iter(['pid', 'name', 'username', 'memory_percent', 'cpu_percent']):
        try:
            cmdline = ' '.join(proc.info['cmdline'])
            if any(script in cmdline for script in ['cpu_stresser.py', 'memory_stresser.py', 'disk_stresser.py']):
                stresser_procs.append(proc.info)
        except (psutil.NoSuchProcess, psutil.AccessDenied):
            continue
    
    # 输出结果
    for proc in stresser_procs:
        print(f"PID: {proc['pid']}, 名称: {proc['name']}, 用户: {proc['username']}")
        print(f"  内存: {proc['memory_percent']:.2f}%, CPU: {proc['cpu_percent']:.2f}%")
        print(f"  命令行: {' '.join(proc['cmdline'])}")
    
    print("==============\n")
    return stresser_procs
```

### 3. 性能分析工具

**内存分析**
```bash
# 使用valgrind分析内存泄漏
valgrind --tool=memcheck --leak-check=full python scripts/dynamic_redundancy.py

# 使用massif分析内存使用
valgrind --tool=massif python scripts/dynamic_redundancy.py
ms_print massif.out.PID > memory_profile.txt
```

**CPU分析**
```bash
# 使用perf分析CPU使用
perf record -g python scripts/dynamic_redundancy.py &
perf report

# 使用gprof分析
gcc -pg -o profiler python scripts/dynamic_redundancy.py
./profiler
gprof profiler gmon.out > cpu_profile.txt
```

**网络分析**
```bash
# 使用tcpdump捕获网络流量
tcpdump -i any -w network_trace.pcap port 61208

# 使用wireshark分析
wireshark -r network_trace.pcap
```

## 预防措施

### 1. 系统监控

**设置监控告警**
```python
# 添加监控告警功能
def check_system_health():
    """检查系统健康状况"""
    alerts = []
    
    # 检查内存使用
    memory = psutil.virtual_memory()
    if memory.percent > 80:
        alerts.append(f"内存使用过高: {memory.percent}%")
    
    # 检查磁盘空间
    for partition in psutil.disk_partitions():
        try:
            usage = psutil.disk_usage(partition.mountpoint)
            if usage.percent > 85:
                alerts.append(f"磁盘空间不足: {partition.mountpoint} {usage.percent}%")
        except:
            continue
    
    # 检查进程数量
    process_count = len(psutil.pids())
    if process_count > 1000:
        alerts.append(f"进程数量过多: {process_count}")
    
    return alerts
```

**定期健康检查**
```bash
# 创建健康检查脚本
#!/bin/bash
# health_check.sh

echo "=== 系统健康检查 $(date) ==="

# 检查关键进程
ps aux | grep -E "(dynamic_redundancy|glances)" | grep -v grep

# 检查磁盘空间
df -h | grep -E "(data|root)"

# 检查内存使用
free -h

# 检查网络连接
netstat -tlnp | grep 61208

echo "=== 检查完成 ==="
```

### 2. 自动化维护

**定时清理任务**
```bash
# 添加到crontab
# 每天凌晨2点清理临时文件
0 2 * * * find /tmp -name "*stress*" -mtime +1 -delete

# 每周清理日志文件
0 3 * * 0 find /path/to/logs -name "*.log" -mtime +30 -delete

# 每小时检查系统状态
0 * * * * /path/to/health_check.sh >> /path/to/system.log 2>&1
```

**自动重启机制**
```python
# 添加自动重启功能
import signal
import sys

def graceful_shutdown(signum, frame):
    """优雅关闭处理"""
    logger.info("收到关闭信号，正在优雅关闭...")
    # 执行清理操作
    cleanup_resources()
    sys.exit(0)

# 注册信号处理器
signal.signal(signal.SIGTERM, graceful_shutdown)
signal.signal(signal.SIGINT, graceful_shutdown)
```

### 3. 配置备份与恢复

**配置版本控制**
```bash
# 初始化Git仓库
cd config
git init
git add .
git commit -m "初始配置"

# 定期提交配置变更
git add . && git commit -m "配置更新 $(date)"
```

**配置备份脚本**
```bash
#!/bin/bash
# backup_config.sh

BACKUP_DIR="/backup/config/$(date +%Y%m%d)"
mkdir -p "$BACKUP_DIR"

# 备份配置文件
cp -r config/* "$BACKUP_DIR/"

# 备份环境变量
env | grep CLOUD_RESOURCE > "$BACKUP_DIR"/environment_vars.txt

# 压缩备份
tar -czf "$BACKUP_DIR".tar.gz -C "$BACKUP_DIR" .

# 清理临时目录
rm -rf "$BACKUP_DIR"

echo "配置备份完成: $BACKUP_DIR.tar.gz"
```

通过遵循本故障排除指南，用户可以有效地识别、诊断和解决CloudResourceOptimizer项目中遇到的各种问题。建议定期进行系统维护和健康检查，以预防潜在问题的发生。