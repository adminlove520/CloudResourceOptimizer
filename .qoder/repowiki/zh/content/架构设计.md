# CloudResourceOptimizer 架构设计文档

<cite>
**本文档引用的文件**
- [README.md](file://README.md)
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py)
- [scripts/memory_stresser.py](file://scripts/memory_stresser.py)
- [scripts/cpu_stresser.py](file://scripts/cpu_stresser.py)
- [scripts/disk_stresser.py](file://scripts/disk_stresser.py)
- [Recover/recover_system.py](file://Recover/recover_system.py)
- [start_dynamic_redundancy.bat](file://start_dynamic_redundancy.bat)
- [start_dynamic_redundancy.sh](file://start_dynamic_redundancy.sh)
- [requirements.txt](file://requirements.txt)
</cite>

## 目录
1. [引言](#引言)
2. [项目概述](#项目概述)
3. [整体架构设计](#整体架构设计)
4. [核心组件分析](#核心组件分析)
5. [数据流与控制流程](#数据流与控制流程)
6. [跨平台支持设计](#跨平台支持设计)
7. [依赖关系分析](#依赖关系分析)
8. [可扩展性评估](#可扩展性评估)
9. [总结](#总结)

## 引言

CloudResourceOptimizer 是一个面向云主机资源利用率管理的智能优化系统。该系统采用模块化架构设计，通过五个核心层次实现对CPU、内存、磁盘资源的动态调控，确保云主机资源利用率符合监管要求。本文档将深入分析系统的整体架构设计思想、核心组件实现原理以及未来的扩展潜力。

## 项目概述

CloudResourceOptimizer 项目旨在解决云主机资源利用率优化问题，通过智能调控系统资源占用，实现资源的高效利用和优化管理。系统具备以下核心特性：

- **自适应资源调控**：根据云主机内存规格自动区分小规格（≤8GB）和大规格（≥16GB），并相应调整资源利用率目标
- **多维度资源监控**：实时监控CPU、内存、磁盘的利用率，并维护30天平均利用率统计数据
- **跨平台兼容性**：支持Windows和Linux系统，具备自动平台检测和差异化处理能力
- **完整恢复机制**：提供独立的系统资源恢复脚本，确保系统资源可完全恢复到正常状态

## 整体架构设计

### 面向对象模块化设计思想

系统采用面向对象的模块化设计思想，将整体架构划分为五个核心层次，每个层次承担特定的功能职责：

```mermaid
graph TB
subgraph "应用层"
Main[主控制器<br/>dynamic_redundancy.py]
Startup[启动脚本<br/>start_*.bat/sh]
end
subgraph "控制层"
RC[RedundancyController<br/>主控制器]
SM[SystemMonitor<br/>系统监控]
GM[GlancesMonitor<br/>性能监控]
end
subgraph "服务层"
CM[ConfigManager<br/>配置管理]
Logger[Logger<br/>日志服务]
end
subgraph "资源层"
MS[MemoryStresser<br/>内存占用]
CS[CPUStresser<br/>CPU占用]
DS[DiskStresser<br/>磁盘占用]
end
subgraph "恢复层"
RS[RecoverySystem<br/>系统恢复]
end
Main --> RC
Main --> SM
Main --> GM
RC --> CM
RC --> Logger
RC --> SM
SM --> CM
SM --> Logger
GM --> CM
GM --> Logger
RC --> MS
RC --> CS
RC --> DS
Startup --> Main
RS --> RC
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L1-L730)
- [start_dynamic_redundancy.bat](file://start_dynamic_redundancy.bat#L1-L24)
- [start_dynamic_redundancy.sh](file://start_dynamic_redundancy.sh#L1-L104)

### 五大层次架构详解

#### 1. 配置管理层（ConfigManager）

ConfigManager 采用单例模式设计，负责统一管理所有配置项，提供全局配置访问接口：

```mermaid
classDiagram
class ConfigManager {
-dict config
+load_config() void
+get(key, default) any
-parse_env_variables() dict
-validate_config() bool
}
class EnvironmentLoader {
+load_dotenv(path) void
+getenv(key, default) string
}
ConfigManager --> EnvironmentLoader : "使用"
ConfigManager : "单例模式"
ConfigManager : "配置验证"
ConfigManager : "默认值处理"
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L25-L100)

#### 2. 日志服务层（Logger）

Logger 服务模式实现多目的地日志输出，支持文件和控制台双重输出：

```mermaid
classDiagram
class Logger {
-Logger logger
-string log_file
+info(message) void
+warning(message) void
+error(message) void
+debug(message) void
-setup_logging() void
}
class LoggingHandler {
+FileHandler file_handler
+StreamHandler console_handler
}
Logger --> LoggingHandler : "使用"
Logger : "多目的地输出"
Logger : "日期分片日志"
Logger : "格式化输出"
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L102-L130)

#### 3. 系统监控层（SystemMonitor）

SystemMonitor 采用观察者模式设计，实时采集系统资源数据：

```mermaid
classDiagram
class SystemMonitor {
-ConfigManager config
-Logger logger
-string system_spec
+detect_system_spec() string
+get_system_info() dict
+get_resource_usage() dict
-collect_cpu_data() float
-collect_memory_data() float
-collect_disk_data() float
}
class ResourceCollector {
+psutil.cpu_percent() float
+psutil.virtual_memory() MemoryInfo
+psutil.disk_partitions() list
}
SystemMonitor --> ResourceCollector : "使用"
SystemMonitor : "观察者模式"
SystemMonitor : "历史数据维护"
SystemMonitor : "平均利用率计算"
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L132-L250)

#### 4. 冗余控制层（RedundancyController）

RedundancyController 作为系统中枢，协调各组件工作，形成完整的控制闭环：

```mermaid
sequenceDiagram
participant Main as 主控制器
participant Monitor as 系统监控
participant Controller as 冗余控制器
participant Memory as 内存占用
participant CPU as CPU占用
participant Disk as 磁盘占用
Main->>Monitor : 获取资源使用情况
Monitor-->>Main : 返回当前使用率
Main->>Controller : 调整资源使用率
Controller->>Controller : 计算差值需求
Controller->>Memory : 创建内存占用进程
Controller->>CPU : 创建CPU占用进程
Controller->>Disk : 创建磁盘临时文件
Memory-->>Controller : 内存占用完成
CPU-->>Controller : CPU占用完成
Disk-->>Controller : 磁盘占用完成
Controller-->>Main : 调整完成
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L252-L500)

#### 5. 外部监控集成层（GlancesMonitor）

GlancesMonitor 集成第三方监控工具，提供Web界面的实时性能监控：

```mermaid
classDiagram
class GlancesMonitor {
-ConfigManager config
-Logger logger
-subprocess process
+start() void
+stop() void
-check_glances_installation() bool
-launch_web_server() void
}
class GlancesProcess {
+subprocess.Popen process
+wait_for_exit() void
+terminate() void
}
GlancesMonitor --> GlancesProcess : "管理"
GlancesMonitor : "Web界面监控"
GlancesMonitor : "自动安装支持"
GlancesMonitor : "配置化启动"
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L502-L530)

**章节来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L25-L730)
- [README.md](file://README.md#L1-L217)

## 核心组件分析

### ConfigManager 单例模式配置管理

ConfigManager 采用单例模式设计，确保整个系统只有一个配置实例，提供统一的配置访问接口：

```python
# 配置加载示例
self.config['SMALL_MEMORY_MAX'] = int(os.getenv('SMALL_MEMORY_MAX', 8))
self.config['LARGE_MEMORY_MIN'] = int(os.getenv('LARGE_MEMORY_MIN', 16))
self.config['TARGET_UTILIZATION_SMALL'] = int(os.getenv('TARGET_UTILIZATION_SMALL', 25))
self.config['TARGET_UTILIZATION_LARGE'] = int(os.getenv('TARGET_UTILIZATION_LARGE', 40))
```

**关键特性**：
- **环境变量优先**：优先从.env文件读取配置，支持运行时动态调整
- **默认值保护**：提供合理的默认值，确保配置缺失时系统仍能正常运行
- **类型转换**：自动进行配置值的类型转换和验证
- **集中管理**：所有配置项集中存储，便于维护和审计

### Logger 服务模式多目的地输出

Logger 采用服务模式设计，支持同时向文件和控制台输出日志：

```python
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler(log_file),
        logging.StreamHandler()
    ]
)
```

**设计优势**：
- **双输出机制**：实时日志既保存到文件便于后续分析，又显示在控制台便于即时监控
- **日期分片**：按日期生成日志文件，避免单个文件过大
- **格式标准化**：统一的日志格式便于日志分析和问题定位
- **级别分类**：支持不同级别的日志输出，便于调试和生产环境使用

### SystemMonitor 观察者模式实时监控

SystemMonitor 采用观察者模式设计，持续监控系统资源使用情况：

```mermaid
flowchart TD
Start([开始监控]) --> DetectSpec[检测系统规格]
DetectSpec --> CollectData[收集资源数据]
CollectData --> CalcAvg[计算平均利用率]
CalcAvg --> StoreHistory[存储历史数据]
StoreHistory --> CheckThreshold{检查阈值}
CheckThreshold --> |低于目标| TriggerAdjust[触发资源调整]
CheckThreshold --> |达到目标| ContinueMonitor[继续监控]
TriggerAdjust --> AdjustResources[调整资源使用]
AdjustResources --> ContinueMonitor
ContinueMonitor --> WaitInterval[等待监控间隔]
WaitInterval --> CollectData
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L132-L250)

**监控特性**：
- **实时采集**：使用psutil库实时获取系统资源使用情况
- **历史维护**：维护30天监控周期的历史数据，支持趋势分析
- **平均计算**：计算各资源的平均利用率，避免瞬时波动影响决策
- **异常处理**：完善的异常处理机制，确保监控服务的稳定性

### RedundancyController 主控制器协调机制

RedundancyController 作为系统的核心协调器，负责整个资源调控流程：

```mermaid
flowchart TD
InitController[初始化控制器] --> LoadConfig[加载配置]
LoadConfig --> DetectSpec[检测系统规格]
DetectSpec --> SetTarget[设置目标利用率]
SetTarget --> StartLoop[开始主循环]
StartLoop --> GetUsage[获取当前使用率]
GetUsage --> CompareTarget{比较目标值}
CompareTarget --> |低于目标| CalcDiff[计算差值需求]
CompareTarget --> |达到目标| SleepInterval[等待监控间隔]
CalcDiff --> AdjustMemory[调整内存使用]
AdjustMemory --> AdjustCPU[调整CPU使用]
AdjustCPU --> AdjustDisk[调整磁盘使用]
AdjustDisk --> LogResult[记录调整结果]
LogResult --> SleepInterval
SleepInterval --> GetUsage
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L252-L730)

**控制逻辑**：
- **自适应调整**：根据系统规格和当前使用情况动态调整资源
- **多资源协调**：同时调整CPU、内存、磁盘三种资源，确保整体平衡
- **渐进式调节**：采用渐进式的调整策略，避免系统资源剧烈波动
- **资源隔离**：每种资源的调整相互独立，降低系统风险

**章节来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L25-L730)

## 数据流与控制流程

### 配置加载→系统检测→目标设定→资源监控→差值计算→调节执行 数据流闭环

系统采用完整的数据流闭环设计，确保资源调控的准确性和有效性：

```mermaid
sequenceDiagram
participant Config as 配置管理
participant Monitor as 系统监控
participant Controller as 冗余控制器
participant Resources as 资源脚本
participant History as 历史数据
Config->>Config : 加载.env配置文件
Config->>Monitor : 提供配置参数
Monitor->>Monitor : 检测系统规格
Monitor->>Controller : 报告系统信息
Controller->>Controller : 设置目标利用率
Controller->>Monitor : 请求当前使用率
Monitor->>History : 查询历史数据
History-->>Monitor : 返回历史统计
Monitor-->>Controller : 返回当前使用率
Controller->>Controller : 计算资源差值
Controller->>Resources : 启动资源占用脚本
Resources-->>Controller : 资源占用完成
Controller->>Monitor : 更新监控数据
Monitor->>History : 存储新的历史记录
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L650-L730)

### dynamic_redundancy.py 对各 stresser 脚本的依赖注入机制

系统采用依赖注入机制，通过动态调用的方式管理各个资源占用脚本：

```mermaid
classDiagram
class DynamicRedundancy {
+run() void
-create_memory_stresser_script() bool
-create_cpu_stresser_script() bool
-detect_platform() string
}
class MemoryStresser {
+占用指定大小内存
+支持MB/GB单位
+可动态调整大小
}
class CPUStresser {
+占用指定线程数CPU
+支持多核并行
+可动态调整线程数
}
class DiskStresser {
+在指定路径创建大文件
+支持多种文件大小
+可设置保留时间
}
DynamicRedundancy --> MemoryStresser : "创建并调用"
DynamicRedundancy --> CPUStresser : "创建并调用"
DynamicRedundancy --> DiskStresser : "创建并调用"
MemoryStresser : "内存资源占用"
CPUStresser : "CPU资源占用"
DiskStresser : "磁盘资源占用"
```

**图表来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L532-L650)

**依赖注入特点**：
- **动态创建**：在运行时动态创建资源占用脚本，确保脚本可用性
- **平台适配**：根据不同平台选择合适的脚本执行方式
- **资源隔离**：每个资源类型独立运行，避免相互干扰
- **生命周期管理**：通过子进程管理资源占用的生命周期

**章节来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L532-L730)

## 跨平台支持设计

### Windows/Linux 启动脚本差异处理

系统提供专门的启动脚本，针对不同平台的特点进行优化：

```mermaid
flowchart TD
StartScript[启动脚本] --> CheckPlatform{检测平台}
CheckPlatform --> |Windows| WinBatch[Windows批处理]
CheckPlatform --> |Linux| LinuxShell[Linux Shell脚本]
WinBatch --> WinCheckPython[检查Python版本]
WinCheckPython --> WinRunScript[运行Python脚本]
WinRunScript --> WinHandleError[错误处理]
LinuxShell --> LinuxCheckPython[检查Python3]
LinuxCheckPython --> LinuxCheckRoot{检查权限}
LinuxCheckRoot --> |非root| WarnRoot[警告权限不足]
LinuxCheckRoot --> |root| LinuxInstallDeps[安装依赖]
WarnRoot --> LinuxInstallDeps
LinuxInstallDeps --> LinuxDetectDist[检测发行版]
LinuxDetectDist --> LinuxInstallPip[安装pip]
LinuxInstallPip --> LinuxInstallPackages[安装包]
LinuxInstallPackages --> LinuxRunScript[运行主脚本]
LinuxRunScript --> LinuxHandleError[错误处理]
```

**图表来源**
- [start_dynamic_redundancy.bat](file://start_dynamic_redundancy.bat#L1-L24)
- [start_dynamic_redundancy.sh](file://start_dynamic_redundancy.sh#L1-L104)

### 平台自动检测逻辑

系统具备完善的平台自动检测能力：

```python
def detect_platform(self):
    """检测操作系统平台"""
    platform_config = self.config.get('PLATFORM', 'auto').lower()
    
    if platform_config != 'auto':
        return platform_config
    
    # 自动检测平台
    system = platform.system().lower()
    if system == 'windows':
        return 'windows'
    elif system == 'linux':
        # 尝试检测Linux发行版
        try:
            with open('/etc/os-release', 'r') as f:
                content = f.read().lower()
                if 'centos' in content:
                    return 'centos'
                elif 'ubuntu' in content:
                    return 'ubuntu'
                elif 'kylin' in content:
                    return 'kylin'
                elif 'openEuler' in content or 'openeuler' in content:
                    return 'openEuler'
        except:
            return 'linux_generic'
    else:
        return 'unknown'
```

**平台支持特性**：
- **自动识别**：自动识别Windows、Linux主流发行版
- **发行版适配**：针对不同Linux发行版提供差异化支持
- **通用兼容**：对于未知平台提供通用配置支持
- **权限检测**：Linux平台检测root权限，提供权限不足警告

**章节来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L350-L400)
- [start_dynamic_redundancy.bat](file://start_dynamic_redundancy.bat#L1-L24)
- [start_dynamic_redundancy.sh](file://start_dynamic_redundancy.sh#L1-L104)

## 依赖关系分析

### 组件间依赖关系图

```mermaid
graph TB
subgraph "核心依赖"
PSUTIL[psutil>=5.9.0]
DOTENV[python-dotenv>=1.0.0]
GLANCES[glances>=3.2.7]
BOTTLE[bottle>=0.12.23]
end
subgraph "系统组件"
DR[dynamic_redundancy.py]
MS[memory_stresser.py]
CS[cpu_stresser.py]
DS[disk_stresser.py]
RS[recover_system.py]
end
subgraph "启动脚本"
BAT[start_dynamic_redundancy.bat]
SH[start_dynamic_redundancy.sh]
end
DR --> PSUTIL
DR --> DOTENV
DR --> GLANCES
DR --> BOTTLE
DR --> MS
DR --> CS
DR --> DS
DR --> RS
SH --> DR
BAT --> DR
```

**图表来源**
- [requirements.txt](file://requirements.txt#L1-L5)
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L1-L20)

### 依赖层次分析

**第一层：基础依赖**
- **psutil**：系统资源监控的基础库，提供跨平台的系统信息获取能力
- **python-dotenv**：环境变量管理，支持配置文件的加载和解析

**第二层：功能依赖**
- **glances**：第三方监控工具，提供Web界面的实时性能监控
- **bottle**：Web框架，支持Glances的Web服务器功能

**第三层：业务依赖**
- **stresser脚本**：资源占用的核心实现，由主控制器动态调用
- **恢复脚本**：系统资源恢复的核心实现，提供完整的资源清理能力

**章节来源**
- [requirements.txt](file://requirements.txt#L1-L5)
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L1-L20)

## 可扩展性评估

### 当前架构的可扩展性分析

CloudResourceOptimizer 的架构设计具有良好的可扩展性，主要体现在以下几个方面：

#### 1. 模块化设计支持新功能添加

```mermaid
graph LR
subgraph "现有模块"
CPU[CPU监控]
Memory[内存监控]
Disk[磁盘监控]
end
subgraph "扩展点"
Network[网络监控]
GPU[GPU监控]
Storage[存储监控]
end
subgraph "新功能"
TrafficControl[流量控制]
LoadBalancing[负载均衡]
Performance[性能分析]
end
CPU --> Network
Memory --> GPU
Disk --> Storage
Network --> TrafficControl
GPU --> LoadBalancing
Storage --> Performance
```

#### 2. 新功能潜在接入点

**网络流量控制接入点**：
- **监控层扩展**：在SystemMonitor中添加网络流量监控
- **控制层扩展**：在RedundancyController中添加网络流量调节逻辑
- **脚本层扩展**：创建network_stresser.py脚本实现网络流量占用

**负载均衡接入点**：
- **配置层扩展**：在ConfigManager中添加负载均衡相关配置
- **监控层扩展**：扩展SystemMonitor的监控范围
- **控制层扩展**：在RedundancyController中添加负载均衡算法

**性能分析接入点**：
- **历史数据分析**：扩展resource_history的数据结构，支持更复杂的数据分析
- **机器学习集成**：集成机器学习算法进行预测性资源调整
- **可视化增强**：扩展GlancesMonitor的可视化能力

#### 3. 扩展设计原则

**插件化架构**：新功能可以通过插件化的方式集成，无需修改核心代码
**配置驱动**：通过配置文件控制新功能的启用和参数设置
**接口标准化**：新功能需要遵循现有的接口规范，确保系统一致性
**向后兼容**：新功能的添加不会影响现有功能的正常运行

**章节来源**
- [scripts/dynamic_redundancy.py](file://scripts/dynamic_redundancy.py#L25-L730)

## 总结

CloudResourceOptimizer 采用了先进的面向对象模块化设计理念，构建了一个完整、稳定、可扩展的云主机资源优化系统。通过五个核心层次的清晰分工和紧密协作，系统实现了：

### 架构优势

1. **清晰的层次划分**：配置管理、日志服务、系统监控、冗余控制、外部监控集成五大层次，职责明确，耦合度低
2. **单例模式配置管理**：ConfigManager采用单例模式，确保配置的一致性和可靠性
3. **观察者模式监控**：SystemMonitor采用观察者模式，实现实时、高效的系统资源监控
4. **主控制器协调机制**：RedundancyController作为系统中枢，协调各组件工作，形成完整的控制闭环
5. **跨平台支持**：完善的Windows/Linux平台支持，具备自动检测和差异化处理能力

### 设计亮点

1. **数据流闭环设计**：从配置加载到资源监控再到调节执行的完整数据流闭环，确保系统运行的准确性和有效性
2. **依赖注入机制**：通过动态调用的方式管理资源占用脚本，提高系统的灵活性和可维护性
3. **多目的地日志输出**：Logger服务模式支持文件和控制台双重输出，便于系统监控和问题排查
4. **自适应资源调控**：根据系统规格自动调整资源利用率目标，实现智能化的资源管理

### 可扩展性展望

系统架构设计充分考虑了未来的扩展需求，为添加网络流量控制、负载均衡、性能分析等功能提供了清晰的接入点和扩展路径。模块化的设计思想和插件化的扩展机制，使得系统能够在保持稳定性的前提下，逐步演进和完善。

CloudResourceOptimizer 不仅是一个功能完善的资源优化工具，更是一个具有前瞻性的系统架构设计典范，为类似系统的开发提供了宝贵的参考价值。